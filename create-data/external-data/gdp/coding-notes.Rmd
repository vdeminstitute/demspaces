---
title: "GDP imputation"
author: "Andreas Beger, Predictive Heuristics"
date: "`r Sys.Date()`"
output: 
  github_document: 
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library("tidyverse")
library("WDI")
library("states")
library("lubridate")
library("countrycode")
library("lme4")
library("imputeTS")

source("gdp.R")

```

*Last updated on: `r Sys.Date()`*

## WDI GDP data

Relevant WDI indicators:

```
"NY.GDP.PCAP.PP.KD.ZG"
"NY.GDP.PCAP.PP.KD"
"NY.GDP.PCAP.KD.ZG"
"NY.GDP.PCAP.KD"
"NY.GDP.MKTP.PP.KD"
"NY.GDP.MKTP.KD"
"NY.GDP.MKTP.KD.ZG"
"SP.POP.TOTL"
```

```{r}
wdigdp <- WDI(country = "all", start = 1960, end = 2018,
              indicator = c("NY.GDP.MKTP.PP.KD", "NY.GDP.MKTP.PP.CD", "NY.GDP.MKTP.KD"))

wdi <- gdp_wdi_add_gwcode(wdigdp)

wdi$date <- as.Date(sprintf("%s-06-30", wdi$year))
plot_missing(wdi, "NY.GDP.MKTP.KD", "gwcode", "date", "year", "GW") +
  ggtitle("NY.GDP.MKTP.KD")
plot_missing(wdi, "NY.GDP.MKTP.PP.KD", "gwcode", "date", "year", "GW") +
  ggtitle("NY.GDP.MKTP.PP.KD")
plot_missing(wdi, "NY.GDP.MKTP.PP.CD", "gwcode", "date", "year", "GW") +
  ggtitle("NY.GDP.MKTP.PP.CD")
wdi$date <- NULL
```


## KSG expanded GDP

```{r}

ksggdp <- read_delim("input/expgdpv6.0/gdpv6.txt", delim = "\t") %>%
  rename(gwcode = statenum) %>%
  select(-stateid)

ksggdp$date <- as.Date(sprintf("%s-12-31", ksggdp$year))
plot_missing(ksggdp, "realgdp", "gwcode", "date", "year", "GW")
ksggdp$date <- NULL
```

## UN GDP data

```{r}
ungdp <- read_csv("input/UNgdpData.csv") %>%
  select(country_name, country_id, year, gdp_2010USD) 

ungdp <- gdp_un_add_gwcode(ungdp)  
ungdp$date <- as.Date(sprintf("%s-12-31", ungdp$year))
plot_missing(ungdp, "gdp_2010USD", "gwcode", "date", "year", "GW")
ungdp$date <- NULL
```

## Combine data

```{r}
joint <- wdi %>%
  full_join(., ksggdp, by = c("gwcode", "year")) %>%
  select(-pop, -rgdppc, -cgdppc) %>%
  mutate(realgdp = realgdp*1e6) %>%
  full_join(., ungdp, by = c("gwcode", "year")) 
  

# Example countries to look at below
countries <- unique(c(
  c(2, 200, 220, 260, 290, 315, 740, 710),
  sample(unique(joint$gwcode), 4)))
```

## Overlap between UN and WDI

The UN GDP data is almost completely correlated with WDI GDP.

```{r}
# the UN GDP is almost completely correlated with WDI GDP
sum(complete.cases(joint[, c("gdp_2010USD", "NY.GDP.MKTP.KD")]))
cor(joint$gdp_2010USD, joint$NY.GDP.MKTP.KD, use = "complete.obs")

plot(log10(joint$gdp_2010USD), log10(joint$NY.GDP.MKTP.KD))
```

Does it add any non-missing values? Yes, about 800 or so. 

```{r}
# does it add any non-missing values?
joint %>%
  mutate(un_gdp_missing = is.na(gdp_2010USD),
         wdi_gdp_missing = is.na(NY.GDP.MKTP.KD)) %>%
  group_by(un_gdp_missing, wdi_gdp_missing) %>%
  summarize(n = n())
```

For which countries? Somalia, Syria, ...

```{r}
# which countries?
adds <- joint %>% 
  filter(is.na(NY.GDP.MKTP.KD) & !is.na(gdp_2010USD)) %>%
  group_by(gwcode) %>%
  summarize(adds = n())
head(arrange(adds, desc(adds)))
```


```{r}
# look at some examples of those
set.seed(1343)
countries2 <- unique(c(c(290, 345), 
                       sample(adds$gwcode, 8)))

mdl <- lm(NY.GDP.MKTP.KD ~ -1 + gdp_2010USD, data = joint)
joint <- joint %>%
  mutate(gdp_2010USD.rescaled = predict(mdl, newdata = joint))
joint %>%
  gather(var, value, -gwcode, -year, -origin, -realgdp, -NY.GDP.MKTP.PP.KD, -gdp_2010USD) %>%
  filter(gwcode %in% countries2) %>%
  ggplot(aes(x = year, y = value, colour = var, group = interaction(gwcode, var))) +
  geom_line(alpha = .5) +
  facet_wrap(~ gwcode, scales = "free_y")
joint %>%
  gather(var, value, -gwcode, -year, -origin, -NY.GDP.MKTP.PP.KD, -gdp_2010USD) %>%
  filter(gwcode %in% countries) %>%
  ggplot(aes(x = year, y = value, colour = var, group = interaction(gwcode, var))) +
  geom_line(alpha = .5) +
  facet_wrap(~ gwcode, scales = "free_y")
```

Rescaled UN GDP matches WDI very well, it seems. Adjusted R^2 is basically 1 and so is the coefficient. 

## Overlap between KSG expanded and WDI

```{r}
sum(complete.cases(joint[, c("realgdp", "NY.GDP.MKTP.PP.KD")]))
cor(joint$realgdp, joint$NY.GDP.MKTP.PP.KD, use = "complete.obs")

sum(complete.cases(joint[, c("realgdp", "NY.GDP.MKTP.KD")]))
cor(joint$realgdp, joint$NY.GDP.MKTP.KD, use = "complete.obs")
```

Plain linear rescaling doesn't work well.

```{r}
# Plain linear rescaling; doesn't work well
mdl <- lm(NY.GDP.MKTP.KD ~ -1 + realgdp, data = joint)
summary(mdl)
joint <- joint %>%
  mutate(realgdp.rescaled = predict(mdl, newdata = joint))
joint %>%
  gather(var, value, -gwcode, -year, -origin, -NY.GDP.MKTP.PP.KD, -starts_with("gdp_2010")) %>%
  filter(gwcode %in% countries) %>%
  ggplot(aes(x = year, y = value, colour = var, group = interaction(gwcode, var))) +
  geom_line(alpha = .5) +
  facet_wrap(~ gwcode, scales = "free_y")

plot(log10(joint$realgdp), log10(joint$NY.GDP.MKTP.KD))
plot(log10(joint$realgdp.rescaled), log10(joint$NY.GDP.MKTP.KD))
```

Try log model, also doesn't work super well. 

```{r}
# Try log log model; also doesn't work well
mdl <- lm(log(NY.GDP.MKTP.KD) ~ -1 + log(realgdp), data = joint)
summary(mdl)
joint <- joint %>%
  mutate(realgdp.rescaled2 = exp(predict(mdl, newdata = joint)))
joint %>%
  gather(var, value, -gwcode, -year, -origin, -NY.GDP.MKTP.PP.KD, -starts_with("gdp_2010")) %>%
  filter(gwcode %in% countries) %>%
  ggplot(aes(x = year, y = value, colour = var, group = interaction(gwcode, var))) +
  geom_line() +
  facet_wrap(~ gwcode, scales = "free_y")

plot(log10(joint$realgdp), log10(joint$NY.GDP.MKTP.KD))
abline(a = 0, b = 1)
plot(log10(joint$realgdp.rescaled2), log10(joint$NY.GDP.MKTP.KD))
abline(a = 0, b = 1)
```

Try scaling by country:

```{r}
# try country-varying scaling factors; this works fairly well
library("lme4")
mdl <- lmer(log(NY.GDP.MKTP.KD) ~ -1 + log(realgdp) + (log(realgdp)|gwcode), data = joint)
joint <- joint %>%
  mutate(realgdp.rescaled3 = exp(predict(mdl, newdata = joint, allow.new.levels = TRUE)))
joint %>%
  gather(var, value, -gwcode, -year, -origin, -realgdp.rescaled, -realgdp.rescaled2,
         -starts_with("gdp_2010"), -NY.GDP.MKTP.PP.KD) %>%
  filter(gwcode %in% countries) %>%
  ggplot(aes(x = year, y = value, colour = var, group = interaction(gwcode, var))) +
  geom_line() +
  facet_wrap(~ gwcode, scales = "free_y")

plot(log10(joint$realgdp), log10(joint$NY.GDP.MKTP.KD))
abline(a = 0, b = 1)
plot(log10(joint$realgdp.rescaled3), log10(joint$NY.GDP.MKTP.KD))
abline(a = 0, b = 1)
```


## Joint model of UN and KSG predicting WDI

```{r}
mdl_combo <- lmer(log(NY.GDP.MKTP.KD) ~ -1 + log(gdp_2010USD) + log(realgdp) + (log(realgdp)|gwcode), data = joint)
joint <- joint %>%
  mutate(NY.GDP.MKTP.KD.hat = exp(predict(mdl_combo, newdata = joint, allow.new.levels = TRUE)))
joint %>%
  gather(var, value, -gwcode, -year, -origin, -realgdp, -realgdp.rescaled, -realgdp.rescaled2, -realgdp.rescaled3,
         -starts_with("gdp_2010"), -NY.GDP.MKTP.PP.KD) %>%
  filter(gwcode %in% countries) %>%
  ggplot(aes(x = year, y = value, colour = var, group = interaction(gwcode, var))) +
  geom_line() +
  facet_wrap(~ gwcode, scales = "free_y")
joint %>%
  gather(var, value, -gwcode, -year, -origin, -realgdp, -realgdp.rescaled, -realgdp.rescaled2, -realgdp.rescaled3,
         -starts_with("gdp_2010"), -NY.GDP.MKTP.PP.KD) %>%
  filter(gwcode %in% countries2) %>%
  ggplot(aes(x = year, y = value, colour = var, group = interaction(gwcode, var))) +
  geom_line() +
  facet_wrap(~ gwcode, scales = "free_y")
```

This works well, but cannot predict when either KSG or UN is missing, so not useful in practice for filling in WDI gaps.

## Conclusion

Four step imputation procedure:

1. Acquire the WDI data
2. Where WDI is missing, drop in UN GDP figures, scaled by a linear model.
3. Where WDI is missing, drop in KSG figures, scaled by a log-linear country-varying scaling model.
4. Model-based extrapolation: use Kalman-smoothing to forward extrapolate missing GDP values (most notably Taiwan and several countries missing current year GDP values) and backward extrapolate GDP growth in first year of existences of a country.  

Check leftover missing values before impute:

```{r}
source("gdp.R")
joint <- gdp_api(impute = FALSE)

joint$date <- as.Date(sprintf("%s-12-31", joint$year))
p <- plot_missing(joint, "NY.GDP.MKTP.KD", "gwcode", "date", "year", "GW")
joint$date <- NULL
p
  
still_missing <- joint %>% 
  filter(is.na(NY.GDP.MKTP.KD)) %>% 
  group_by(gwcode) %>%
  summarize(n = n(),
            years = paste0(range(year), collapse = " - ")) %>%
  arrange(desc(n))
still_missing
```

Use Kalman smoothing to extrapolate the leftover trailing missing values, and backwards extrapolate first year missing GDP growth. 

```{r}
source("gdp.R")
joint <- gdp_api(impute = TRUE)

joint$date <- as.Date(sprintf("%s-12-31", joint$year))
p <- plot_missing(joint, "NY.GDP.MKTP.KD", "gwcode", "date", "year", "GW")
joint$date <- NULL
p
```

## Check GDP per capita

This uses "population.csv" from the population module.

At least one of the combined GDP values--Qatar in 1971--is clunky in that there is a big discrepancy. This gives Qatar 1971 an inordinarily high GDP per capita value. Solved by backward imputing GDP instead of taking KSG value. 
